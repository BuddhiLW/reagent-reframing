{"version":3,"sources":["rewrite_clj/zip/utils.cljs"],"mappings":";AAKA,AAAA,AAAAA,AAAOG,AACgBI,AAAEC;AADzB,AAAA,AAAAP,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AACIG;AADJ,AAAAF,AAAAD,AAAA,AAAA,AACSI;AADTJ,AACkBK;AADlB,AAEE,AAAMG,AAAE,AAACC,AAAIL,AAAKE;AAAlB,AACE,AAAI,AAACI,AAAIF;AACP,AAAA,AAACG,AACER,AAAK,AAAA,AAAA,AAACS,AAAMR,AAAKE,AAAE,AAACC,AAAAA,AAAAA,AAAEC,AAAAA,AACvB,AAACK,AAAKR;;AACRA;;;AAEN;;;AAAA,AAAMS,AAEHT;AAFH,AAGE,AAAA,AAACH,AAAeG,AAAOU;;AAEzB;;;AAAA,AAAMC,AAEHX;AAFH,AAGE,AAAA,AAACH,AAAeG,AAAOY;;AAGzB,AAAA,AAAMC,AACHC,AAAKC;AADR,AAAA;AAGE,AAAOD,AAAKA;;AAAZ,AACE,AAAME,AAAK,AAACC,AAAOH;AAAnB,AACE,AAAA,AAAAI,AAAQ,AAAAC,AAAKH;AAAL,AAAA,AAAAG;AAAU,AAACJ,AAAAA,AAAAA,AAAGC,AAAAA;;AAAdG;;;AACNL;;AACA,AAAO,AAACM,AAASN;;;;;;;AAEzB;;;;AAAA,AAAMO,AAGHP,AAAKC;AAHR,AAIE,AAAOD,AAAKA;;AAAZ,AACE,AAAAQ,AAAc,AAACE,AAAQV;AAAvB,AAAA,AAAAQ;AAAA,AAAAA,AAASC;AAAT,AACE,AAAI,AAACR,AAAAA,AAAAA,AAAGQ,AAAAA;AACN,AAAO,AAACd,AAAaK;;;;AACrBA;;;AACFA;;;;;AAEN;;;;AAAA,AAAMW,AAGHX,AAAKC;AAHR,AAIE,AAAOD,AAAKA;;AAAZ,AACE,AAAAQ,AAAc,AAACK,AAAOb;AAAtB,AAAA,AAAAQ;AAAA,AAAAA,AAASI;AAAT,AACE,AAAI,AAACX,AAAAA,AAAAA,AAAGW,AAAAA;AACN,AAAO,AAACf,AAAYG;;;;AACpBA;;;AACFA;;;;;AAIN;;;;AAAA,AAAAc,AAAMI;AAAN,AAAA,AAAAH,AAAAD;AAAA,AAAAhC,AAAAiC,AAAA,AAAA,AAGII;AAHJH,AAAA,AAAAlC,AAAAiC,AAAA,AAAA;AAAAC,AAAA,AAAAC,AAAAD;AAAAA,AAGqB/B;AAHrB,AAAAK,AAAA0B,AAAA,AAGcI;AAHdL,AAG+B7B;AAH/B,AAIE,AAAI,AAACK,AAAI6B;AACP,AAAA,AAAC5B,AACE,AAAC6B,AAAKD,AAAOnC,AACA,AAAA,AAAA,AAACqC,AAAexB,AAChB,AAAA,AAAA,AAACL,AACf,AAACC,AAAKR;;AALV;;;AAOF;;;;AAAA,AAAAqC,AAAMG;AAAN,AAAA,AAAAF,AAAAD;AAAA,AAAAzC,AAAA0C,AAAA,AAAA,AAGIL;AAHJM,AAAA,AAAA3C,AAAA0C,AAAA,AAAA;AAAAC,AAAA,AAAAR,AAAAQ;AAAAA,AAGqBxC;AAHrB,AAAAK,AAAAmC,AAAA,AAGcE;AAHdH,AAG+BtC;AAH/B,AAIE,AAAI,AAACK,AAAIoC;AACP,AAAA,AAACnC,AACE,AAACoC,AAAMD,AAAO1C,AACA,AAAA,AAAA,AAACqC,AAAe1B,AAChB,AAAA,AAAA,AAACH,AAChB,AAACC,AAAKR;;AALV;;;AAQF,AAAA,AAAM2C,AAAoB3C;AAA1B,AACE,AAAA4C,AAAmE5C;AAAnE,AAAAJ,AAAAgD,AAAA,AAAA,AAAO9C;AAAP+C,AAAA,AAAAjD,AAAAgD,AAAA,AAAA;AAAAC,AAAA,AAAAd,AAAAc;AAAAA,AAA4D9C;AAA5D,AAAAK,AAAAyC,AAAA,AAAaX;AAAb,AAAA9B,AAAAyC,AAAA,AAAmBC;AAAnB,AAAA1C,AAAAyC,AAAA,AAAiCE;AAAjC,AAAA3C,AAAAyC,AAAA,AAAiDG;AAAjD,AACE,AAAI,AAAA,AAAMjD;AACR,AAAO,AAAAkD,AAAA;;AACP,AAAI,AAAA,AAAM,AAACC,AAAMhB;AACf,AAACiB,AAAK,AAAA,AAAC7C,AAAW,AAAC6B,AAAKD,AACZ,AAAA,AAAA,AAAA,AAAC3B,AAAMR,AAAQ,AAACa,AAAIsB,AACrB,AAAC1B,AAAKR;;AACjB,AAAA,AAACM,AAAW,AAAC8C,AAAYpD,AAAI,AAACmC,AAAKY,AAAQC,AAC/B,AAAA7B,AAAK2B;AAAL,AAAA,AAAA3B;AAAW,AAAA,AAAA,AAACZ,AAAMuC;;AAAlB3B;;AACD,AAACX,AAAKR","names":["p__40654","vec__40655","cljs.core.nth","rewrite-clj.zip.utils/update-in-path","node","path","loc","k","f","v","cljs.core.get","cljs.core/seq","cljs.core/with-meta","cljs.core.assoc","cljs.core/meta","rewrite-clj.zip.utils/remove-right","cljs.core/next","rewrite-clj.zip.utils/remove-left","cljs.core/pop","rewrite-clj.zip.utils/remove-while","zloc","p?","ploc","clojure.zip/prev","cljs.core/not","and__4149__auto__","clojure.zip/remove","rewrite-clj.zip.utils/remove-right-while","temp__5733__auto__","rloc","clojure.zip/right","rewrite-clj.zip.utils/remove-left-while","lloc","clojure.zip/left","p__40691","vec__40692","map__40695","cljs.core/--destructure-map","rewrite-clj.zip.utils/remove-and-move-left","_","l","cljs.core/peek","cljs.core.update_in","p__40706","vec__40707","map__40710","rewrite-clj.zip.utils/remove-and-move-right","r","cljs.core/first","rewrite-clj.zip.utils/remove-and-move-up","vec__40720","map__40723","ppath","pnodes","rs","js/Error","cljs.core/count","clojure.zip/up","clojure.zip/make-node"],"sourcesContent":["(ns ^:no-doc rewrite-clj.zip.utils\n  (:require [clojure.zip :as z]))\n\n;; ## Remove\n\n(defn- update-in-path\n  [[node path :as loc] k f]\n  (let [v (get path k)]\n    (if (seq v)\n      (with-meta\n        [node (assoc path k (f v) :changed? true)]\n        (meta loc))\n      loc)))\n\n(defn remove-right\n  \"Remove right sibling of the current node (if there is one).\"\n  [loc]\n  (update-in-path loc :r next))\n\n(defn remove-left\n  \"Remove left sibling of the current node (if there is one).\"\n  [loc]\n  (update-in-path loc :l pop))\n\n\n(defn remove-while\n  [zloc p?]\n  \"Remove nodes while predicate true. (depth first in reverse!) \"\n  (loop [zloc zloc]\n    (let [ploc (z/prev zloc)]\n      (if-not (and ploc (p? ploc))\n        zloc\n        (recur (z/remove zloc))))))\n\n(defn remove-right-while\n  \"Remove elements to the right of the current zipper location as long as\n   the given predicate matches.\"\n  [zloc p?]\n  (loop [zloc zloc]\n    (if-let [rloc (z/right zloc)]\n      (if (p? rloc)\n        (recur (remove-right zloc))\n        zloc)\n      zloc)))\n\n(defn remove-left-while\n  \"Remove elements to the left of the current zipper location as long as\n   the given predicate matches.\"\n  [zloc p?]\n  (loop [zloc zloc]\n    (if-let [lloc (z/left zloc)]\n      (if (p? lloc)\n        (recur (remove-left zloc))\n        zloc)\n      zloc)))\n\n;; ## Remove and Move\n\n(defn remove-and-move-left\n  \"Remove current node and move left. If current node is at the leftmost\n   location, returns `nil`.\"\n  [[_ {:keys [l] :as path} :as loc]]\n  (if (seq l)\n    (with-meta\n      [(peek l) (-> path\n                    (update-in [:l] pop)\n                    (assoc :changed? true))]\n      (meta loc))))\n\n(defn remove-and-move-right\n  \"Remove current node and move right. If current node is at the rightmost\n   location, returns `nil`.\"\n  [[_ {:keys [r] :as path} :as loc]]\n  (if (seq r)\n    (with-meta\n      [(first r) (-> path\n                     (update-in [:r] next)\n                     (assoc :changed? true))]\n      (meta loc))))\n\n\n(defn remove-and-move-up [loc]\n  (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n    (if (nil? path)\n      (throw (js/Error. \"Remove at top\"))\n      (if (pos? (count l))\n        (z/up (with-meta [(peek l)\n                    (assoc path :l (pop l) :changed? true)]\n                   (meta loc)))\n        (with-meta [(z/make-node loc (peek pnodes) rs)\n                    (and ppath (assoc ppath :changed? true))]\n                   (meta loc))))))\n\n"]}